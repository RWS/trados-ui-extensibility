/* tslint:disable */
/* eslint-disable */
/**
 * RWS Language Cloud API
 * The RWS Language Cloud public API.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ListSourceFileVersionsResponse,
  ListSourceFilesResponse,
  SourceFile,
  SourceFileAttachmentRequest,
  SourceFileAttachmentResponse,
  SourceFilePropertiesResponse,
  SourceFilePropertiesUpdateRequest,
  SourceFileRenameRequest,
  SourceFileRequest,
  SourceFileVersionPropertiesCreateRequest,
  SourceFileVersionResponse,
  SourceFilesUpdateRequest,
} from '../models/index';

export interface AddSourceFileRequest {
    projectId: string;
    authorization: string;
    xLCTenant: string;
    properties: SourceFileRequest;
    file: Blob;
}

export interface AddSourceFileVersionRequest {
    sourceFileId: string;
    taskId: string;
    authorization: string;
    xLCTenant: string;
    properties: SourceFileVersionPropertiesCreateRequest;
    file: Blob;
    fields?: string;
}

export interface AddSourceFilesRequest {
    projectId: string;
    authorization: string;
    xLCTenant: string;
    sourceFileAttachmentRequest: SourceFileAttachmentRequest;
    fields?: string;
}

export interface DownloadSourceFileVersionRequest {
    projectId: string;
    sourceFileId: string;
    fileVersionId: string;
    authorization: string;
    xLCTenant: string;
}

export interface GetSourceFileRequest {
    projectId: string;
    sourceFileId: string;
    authorization: string;
    xLCTenant: string;
    fields?: string;
}

export interface GetSourceFilePropertiesRequest {
    taskId: string;
    sourceFileId: string;
    authorization: string;
    xLCTenant: string;
}

export interface ListSourceFileVersionsRequest {
    projectId: string;
    sourceFileId: string;
    authorization: string;
    xLCTenant: string;
    fields?: string;
}

export interface ListSourceFilesRequest {
    projectId: string;
    authorization: string;
    xLCTenant: string;
    top?: number;
    skip?: number;
    sort?: string;
    fields?: string;
}

export interface UpdateSourceFileRequest {
    projectId: string;
    sourceFileId: string;
    sourceFileRenameRequest?: SourceFileRenameRequest;
}

export interface UpdateSourceFilesRequest {
    projectId: string;
    sourceFilesUpdateRequest?: SourceFilesUpdateRequest;
}

export interface UpdateSourcePropertiesRequest {
    taskId: string;
    sourceFileId: string;
    authorization: string;
    xLCTenant: string;
    sourceFilePropertiesUpdateRequest?: SourceFilePropertiesUpdateRequest;
}

/**
 * 
 */
export class SourceFileApi extends runtime.BaseAPI {

    /**
     * Adds a source file to the project. Files can be uploaded before starting a project or after the project has started. When adding a `translatable` file after the project started, a new start project request should be performed.  Consider the [file and project size limit](https://docs.rws.com/791595/815967/trados-enterprise---accelerate/file-and-project-size-limit) when uploading files.  > Note: The maximum character size of the sum between the `name` and the `path` fields must not exceed 255. Otherwise the request cannot be validated.
     * Add Source File
     */
    async addSourceFileRaw(requestParameters: AddSourceFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SourceFile>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling addSourceFile().'
            );
        }

        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling addSourceFile().'
            );
        }

        if (requestParameters['xLCTenant'] == null) {
            throw new runtime.RequiredError(
                'xLCTenant',
                'Required parameter "xLCTenant" was null or undefined when calling addSourceFile().'
            );
        }

        if (requestParameters['properties'] == null) {
            throw new runtime.RequiredError(
                'properties',
                'Required parameter "properties" was null or undefined when calling addSourceFile().'
            );
        }

        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling addSourceFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        if (requestParameters['xLCTenant'] != null) {
            headerParameters['X-LC-Tenant'] = String(requestParameters['xLCTenant']);
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['properties'] != null) {

            formParams.append('properties', new Blob([JSON.stringify(requestParameters['properties'])], { type: "application/json", }));
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        const response = await this.request({
            path: `/projects/{projectId}/source-files`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Adds a source file to the project. Files can be uploaded before starting a project or after the project has started. When adding a `translatable` file after the project started, a new start project request should be performed.  Consider the [file and project size limit](https://docs.rws.com/791595/815967/trados-enterprise---accelerate/file-and-project-size-limit) when uploading files.  > Note: The maximum character size of the sum between the `name` and the `path` fields must not exceed 255. Otherwise the request cannot be validated.
     * Add Source File
     */
    async addSourceFile(requestParameters: AddSourceFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SourceFile> {
        const response = await this.addSourceFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Adds a new version of the source file in [BCM](https://developers.rws.com/languagecloud-api-docs/articles/BCM.NET_client_API.html) or native format. More information about file formats can be found on the [File formats](../docs/File-formats.md) page.  The version is added on the task represented by `taskId`. To successfully  execute the add operation the task should already be assigned and accepted by a user. If the task is automatic, it\'s possible to add a source file version only when the status of task is `inProgress`.  The file versions added need to respect the output file type declared by the task type of the enclosing task. On the [Rules for sequencing tasks correctly](https://docs.rws.com/791595/885137/trados-enterprise/rules-for-sequencing-tasks-correctly) page from the official RWS Documentation Center, you can find out what output file type is supported by each task.  For adding a source file version using an extension task, the configuration of the task must declare the `scope`\'s value as \"file\".  If the file type of the new added file is different than the supported source file type, the new `fileTypeSettingsId` must be specified in the body or an update of file type should be performed after the add operation, using the [Update Source File Properties](../reference/Public-API.v1.json/paths/~1tasks~1{taskId}~1source-files~1{sourceFileId}/put).  The value of `fileTypeSettingsId` is one of the identifiers listed by the [List File Type Settings](../reference/Public-API.v1.json/paths/~1file-processing-configurations~1{fileProcessingConfigurationId}~1file-type-settings/get) endpoint.  The [List File Type Settings](../reference/Public-API.v1.json/paths/~1file-processing-configurations~1{fileProcessingConfigurationId}~1file-type-settings/get) endpoint must be called with the File Processing Configuration identifier of your project.  The File Processing Configuration of your project can be retrieved from [Get Project](../reference/Public-API.v1.json/paths/~1projects~1{projectId}/get) endpoint.  The multipart parameters in the body should respect and strictly follow the order specified in our documentation.   Consider the [file and project size limit](https://docs.rws.com/791595/815967/trados-enterprise---accelerate/file-and-project-size-limit) when adding files. 
     * Add Source File Version
     */
    async addSourceFileVersionRaw(requestParameters: AddSourceFileVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SourceFileVersionResponse>> {
        if (requestParameters['sourceFileId'] == null) {
            throw new runtime.RequiredError(
                'sourceFileId',
                'Required parameter "sourceFileId" was null or undefined when calling addSourceFileVersion().'
            );
        }

        if (requestParameters['taskId'] == null) {
            throw new runtime.RequiredError(
                'taskId',
                'Required parameter "taskId" was null or undefined when calling addSourceFileVersion().'
            );
        }

        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling addSourceFileVersion().'
            );
        }

        if (requestParameters['xLCTenant'] == null) {
            throw new runtime.RequiredError(
                'xLCTenant',
                'Required parameter "xLCTenant" was null or undefined when calling addSourceFileVersion().'
            );
        }

        if (requestParameters['properties'] == null) {
            throw new runtime.RequiredError(
                'properties',
                'Required parameter "properties" was null or undefined when calling addSourceFileVersion().'
            );
        }

        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling addSourceFileVersion().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fields'] != null) {
            queryParameters['fields'] = requestParameters['fields'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        if (requestParameters['xLCTenant'] != null) {
            headerParameters['X-LC-Tenant'] = String(requestParameters['xLCTenant']);
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['properties'] != null) {

            formParams.append('properties', new Blob([JSON.stringify(requestParameters['properties'])], { type: "application/json", }));
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        const response = await this.request({
            path: `/tasks/{taskId}/source-files/{sourceFileId}/versions`.replace(`{${"sourceFileId"}}`, encodeURIComponent(String(requestParameters['sourceFileId']))).replace(`{${"taskId"}}`, encodeURIComponent(String(requestParameters['taskId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Adds a new version of the source file in [BCM](https://developers.rws.com/languagecloud-api-docs/articles/BCM.NET_client_API.html) or native format. More information about file formats can be found on the [File formats](../docs/File-formats.md) page.  The version is added on the task represented by `taskId`. To successfully  execute the add operation the task should already be assigned and accepted by a user. If the task is automatic, it\'s possible to add a source file version only when the status of task is `inProgress`.  The file versions added need to respect the output file type declared by the task type of the enclosing task. On the [Rules for sequencing tasks correctly](https://docs.rws.com/791595/885137/trados-enterprise/rules-for-sequencing-tasks-correctly) page from the official RWS Documentation Center, you can find out what output file type is supported by each task.  For adding a source file version using an extension task, the configuration of the task must declare the `scope`\'s value as \"file\".  If the file type of the new added file is different than the supported source file type, the new `fileTypeSettingsId` must be specified in the body or an update of file type should be performed after the add operation, using the [Update Source File Properties](../reference/Public-API.v1.json/paths/~1tasks~1{taskId}~1source-files~1{sourceFileId}/put).  The value of `fileTypeSettingsId` is one of the identifiers listed by the [List File Type Settings](../reference/Public-API.v1.json/paths/~1file-processing-configurations~1{fileProcessingConfigurationId}~1file-type-settings/get) endpoint.  The [List File Type Settings](../reference/Public-API.v1.json/paths/~1file-processing-configurations~1{fileProcessingConfigurationId}~1file-type-settings/get) endpoint must be called with the File Processing Configuration identifier of your project.  The File Processing Configuration of your project can be retrieved from [Get Project](../reference/Public-API.v1.json/paths/~1projects~1{projectId}/get) endpoint.  The multipart parameters in the body should respect and strictly follow the order specified in our documentation.   Consider the [file and project size limit](https://docs.rws.com/791595/815967/trados-enterprise---accelerate/file-and-project-size-limit) when adding files. 
     * Add Source File Version
     */
    async addSourceFileVersion(requestParameters: AddSourceFileVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SourceFileVersionResponse> {
        const response = await this.addSourceFileVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Adds multiple source files to the project. Files must be uploaded before attaching them to a project. When a file is attached after the project was started, a new start project request should be performed.   > Note: The maximum character size of the sum between the `name` and the `path` fields must not exceed 255. Otherwise the request cannot be validated. 
     * Attach Source Files
     */
    async addSourceFilesRaw(requestParameters: AddSourceFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SourceFileAttachmentResponse>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling addSourceFiles().'
            );
        }

        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling addSourceFiles().'
            );
        }

        if (requestParameters['xLCTenant'] == null) {
            throw new runtime.RequiredError(
                'xLCTenant',
                'Required parameter "xLCTenant" was null or undefined when calling addSourceFiles().'
            );
        }

        if (requestParameters['sourceFileAttachmentRequest'] == null) {
            throw new runtime.RequiredError(
                'sourceFileAttachmentRequest',
                'Required parameter "sourceFileAttachmentRequest" was null or undefined when calling addSourceFiles().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fields'] != null) {
            queryParameters['fields'] = requestParameters['fields'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        if (requestParameters['xLCTenant'] != null) {
            headerParameters['X-LC-Tenant'] = String(requestParameters['xLCTenant']);
        }

        const response = await this.request({
            path: `/projects/{projectId}/source-files/attach-files`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['sourceFileAttachmentRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Adds multiple source files to the project. Files must be uploaded before attaching them to a project. When a file is attached after the project was started, a new start project request should be performed.   > Note: The maximum character size of the sum between the `name` and the `path` fields must not exceed 255. Otherwise the request cannot be validated. 
     * Attach Source Files
     */
    async addSourceFiles(requestParameters: AddSourceFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SourceFileAttachmentResponse> {
        const response = await this.addSourceFilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Downloads a source file version.
     * Download Source File Version
     */
    async downloadSourceFileVersionRaw(requestParameters: DownloadSourceFileVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling downloadSourceFileVersion().'
            );
        }

        if (requestParameters['sourceFileId'] == null) {
            throw new runtime.RequiredError(
                'sourceFileId',
                'Required parameter "sourceFileId" was null or undefined when calling downloadSourceFileVersion().'
            );
        }

        if (requestParameters['fileVersionId'] == null) {
            throw new runtime.RequiredError(
                'fileVersionId',
                'Required parameter "fileVersionId" was null or undefined when calling downloadSourceFileVersion().'
            );
        }

        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling downloadSourceFileVersion().'
            );
        }

        if (requestParameters['xLCTenant'] == null) {
            throw new runtime.RequiredError(
                'xLCTenant',
                'Required parameter "xLCTenant" was null or undefined when calling downloadSourceFileVersion().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        if (requestParameters['xLCTenant'] != null) {
            headerParameters['X-LC-Tenant'] = String(requestParameters['xLCTenant']);
        }

        const response = await this.request({
            path: `/projects/{projectId}/source-files/{sourceFileId}/versions/{fileVersionId}/download`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))).replace(`{${"sourceFileId"}}`, encodeURIComponent(String(requestParameters['sourceFileId']))).replace(`{${"fileVersionId"}}`, encodeURIComponent(String(requestParameters['fileVersionId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Downloads a source file version.
     * Download Source File Version
     */
    async downloadSourceFileVersion(requestParameters: DownloadSourceFileVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.downloadSourceFileVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a source file from the project.
     * Get Source File
     */
    async getSourceFileRaw(requestParameters: GetSourceFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SourceFile>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling getSourceFile().'
            );
        }

        if (requestParameters['sourceFileId'] == null) {
            throw new runtime.RequiredError(
                'sourceFileId',
                'Required parameter "sourceFileId" was null or undefined when calling getSourceFile().'
            );
        }

        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling getSourceFile().'
            );
        }

        if (requestParameters['xLCTenant'] == null) {
            throw new runtime.RequiredError(
                'xLCTenant',
                'Required parameter "xLCTenant" was null or undefined when calling getSourceFile().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fields'] != null) {
            queryParameters['fields'] = requestParameters['fields'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        if (requestParameters['xLCTenant'] != null) {
            headerParameters['X-LC-Tenant'] = String(requestParameters['xLCTenant']);
        }

        const response = await this.request({
            path: `/projects/{projectId}/source-files/{sourceFileId}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))).replace(`{${"sourceFileId"}}`, encodeURIComponent(String(requestParameters['sourceFileId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves a source file from the project.
     * Get Source File
     */
    async getSourceFile(requestParameters: GetSourceFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SourceFile> {
        const response = await this.getSourceFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the properties for a source file.
     * Get Source File Properties
     */
    async getSourceFilePropertiesRaw(requestParameters: GetSourceFilePropertiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SourceFilePropertiesResponse>> {
        if (requestParameters['taskId'] == null) {
            throw new runtime.RequiredError(
                'taskId',
                'Required parameter "taskId" was null or undefined when calling getSourceFileProperties().'
            );
        }

        if (requestParameters['sourceFileId'] == null) {
            throw new runtime.RequiredError(
                'sourceFileId',
                'Required parameter "sourceFileId" was null or undefined when calling getSourceFileProperties().'
            );
        }

        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling getSourceFileProperties().'
            );
        }

        if (requestParameters['xLCTenant'] == null) {
            throw new runtime.RequiredError(
                'xLCTenant',
                'Required parameter "xLCTenant" was null or undefined when calling getSourceFileProperties().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        if (requestParameters['xLCTenant'] != null) {
            headerParameters['X-LC-Tenant'] = String(requestParameters['xLCTenant']);
        }

        const response = await this.request({
            path: `/tasks/{taskId}/source-files/{sourceFileId}`.replace(`{${"taskId"}}`, encodeURIComponent(String(requestParameters['taskId']))).replace(`{${"sourceFileId"}}`, encodeURIComponent(String(requestParameters['sourceFileId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the properties for a source file.
     * Get Source File Properties
     */
    async getSourceFileProperties(requestParameters: GetSourceFilePropertiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SourceFilePropertiesResponse> {
        const response = await this.getSourceFilePropertiesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves all the versions of a source file.
     * List Source File Versions
     */
    async listSourceFileVersionsRaw(requestParameters: ListSourceFileVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListSourceFileVersionsResponse>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling listSourceFileVersions().'
            );
        }

        if (requestParameters['sourceFileId'] == null) {
            throw new runtime.RequiredError(
                'sourceFileId',
                'Required parameter "sourceFileId" was null or undefined when calling listSourceFileVersions().'
            );
        }

        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling listSourceFileVersions().'
            );
        }

        if (requestParameters['xLCTenant'] == null) {
            throw new runtime.RequiredError(
                'xLCTenant',
                'Required parameter "xLCTenant" was null or undefined when calling listSourceFileVersions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fields'] != null) {
            queryParameters['fields'] = requestParameters['fields'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        if (requestParameters['xLCTenant'] != null) {
            headerParameters['X-LC-Tenant'] = String(requestParameters['xLCTenant']);
        }

        const response = await this.request({
            path: `/projects/{projectId}/source-files/{sourceFileId}/versions`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))).replace(`{${"sourceFileId"}}`, encodeURIComponent(String(requestParameters['sourceFileId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves all the versions of a source file.
     * List Source File Versions
     */
    async listSourceFileVersions(requestParameters: ListSourceFileVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListSourceFileVersionsResponse> {
        const response = await this.listSourceFileVersionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the source files in a project.
     * List Source Files
     */
    async listSourceFilesRaw(requestParameters: ListSourceFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListSourceFilesResponse>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling listSourceFiles().'
            );
        }

        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling listSourceFiles().'
            );
        }

        if (requestParameters['xLCTenant'] == null) {
            throw new runtime.RequiredError(
                'xLCTenant',
                'Required parameter "xLCTenant" was null or undefined when calling listSourceFiles().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['top'] != null) {
            queryParameters['top'] = requestParameters['top'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['fields'] != null) {
            queryParameters['fields'] = requestParameters['fields'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        if (requestParameters['xLCTenant'] != null) {
            headerParameters['X-LC-Tenant'] = String(requestParameters['xLCTenant']);
        }

        const response = await this.request({
            path: `/projects/{projectId}/source-files`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the source files in a project.
     * List Source Files
     */
    async listSourceFiles(requestParameters: ListSourceFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListSourceFilesResponse> {
        const response = await this.listSourceFilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a source file.
     * Update Source File
     */
    async updateSourceFileRaw(requestParameters: UpdateSourceFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling updateSourceFile().'
            );
        }

        if (requestParameters['sourceFileId'] == null) {
            throw new runtime.RequiredError(
                'sourceFileId',
                'Required parameter "sourceFileId" was null or undefined when calling updateSourceFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/projects/{projectId}/source-files/{sourceFileId}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))).replace(`{${"sourceFileId"}}`, encodeURIComponent(String(requestParameters['sourceFileId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['sourceFileRenameRequest'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates a source file.
     * Update Source File
     */
    async updateSourceFile(requestParameters: UpdateSourceFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateSourceFileRaw(requestParameters, initOverrides);
    }

    /**
     * Updates multiple source files. If any of the files fails to be updated, an error will be returned for each file. 
     * Update Source Files
     */
    async updateSourceFilesRaw(requestParameters: UpdateSourceFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling updateSourceFiles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/projects/{projectId}/source-files`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['sourceFilesUpdateRequest'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates multiple source files. If any of the files fails to be updated, an error will be returned for each file. 
     * Update Source Files
     */
    async updateSourceFiles(requestParameters: UpdateSourceFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateSourceFilesRaw(requestParameters, initOverrides);
    }

    /**
     * Updates the properties of the source file.   The value of `fileTypeSettingsId` should be one of the identifiers listed by the [List File Type Settings](../reference/Public-API.v1.json/paths/~1file-processing-configurations~1{fileProcessingConfigurationId}~1file-type-settings/get)  endpoint called with an identifier of a File Processing Configuration that exists on the project. The list of File Processing Configurations from a project can be retrieved by using the [List File Processing Configurations](../reference/Public-API.v1.json/paths/~1file-processing-configurations/get) endpoint.
     * Update Source File Properties
     */
    async updateSourcePropertiesRaw(requestParameters: UpdateSourcePropertiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['taskId'] == null) {
            throw new runtime.RequiredError(
                'taskId',
                'Required parameter "taskId" was null or undefined when calling updateSourceProperties().'
            );
        }

        if (requestParameters['sourceFileId'] == null) {
            throw new runtime.RequiredError(
                'sourceFileId',
                'Required parameter "sourceFileId" was null or undefined when calling updateSourceProperties().'
            );
        }

        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling updateSourceProperties().'
            );
        }

        if (requestParameters['xLCTenant'] == null) {
            throw new runtime.RequiredError(
                'xLCTenant',
                'Required parameter "xLCTenant" was null or undefined when calling updateSourceProperties().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        if (requestParameters['xLCTenant'] != null) {
            headerParameters['X-LC-Tenant'] = String(requestParameters['xLCTenant']);
        }

        const response = await this.request({
            path: `/tasks/{taskId}/source-files/{sourceFileId}`.replace(`{${"taskId"}}`, encodeURIComponent(String(requestParameters['taskId']))).replace(`{${"sourceFileId"}}`, encodeURIComponent(String(requestParameters['sourceFileId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['sourceFilePropertiesUpdateRequest'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates the properties of the source file.   The value of `fileTypeSettingsId` should be one of the identifiers listed by the [List File Type Settings](../reference/Public-API.v1.json/paths/~1file-processing-configurations~1{fileProcessingConfigurationId}~1file-type-settings/get)  endpoint called with an identifier of a File Processing Configuration that exists on the project. The list of File Processing Configurations from a project can be retrieved by using the [List File Processing Configurations](../reference/Public-API.v1.json/paths/~1file-processing-configurations/get) endpoint.
     * Update Source File Properties
     */
    async updateSourceProperties(requestParameters: UpdateSourcePropertiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateSourcePropertiesRaw(requestParameters, initOverrides);
    }

}
