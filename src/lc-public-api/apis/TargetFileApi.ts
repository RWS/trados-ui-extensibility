/* tslint:disable */
/* eslint-disable */
/**
 * RWS Language Cloud API
 * The RWS Language Cloud public API.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  FileVersionExport,
  FileVersionImport,
  ListTargetFileVersionsResponse,
  ListTargetFilesResponse,
  TargetFile,
  TargetFileRenameRequest,
  TargetFileVersion,
  TargetFileVersionPropertiesCreateRequest,
  TargetFileVersionResponse,
  TargetFilesUpdateRequest,
} from '../models/index';

export interface AddTargetFileVersionRequest {
    taskId: string;
    targetFileId: string;
    authorization: string;
    xLCTenant: string;
    properties: TargetFileVersionPropertiesCreateRequest;
    file: Blob;
    fields?: string;
}

export interface DownloadExportedTargetFileVersionRequest {
    projectId: string;
    targetFileId: string;
    fileVersionId: string;
    exportId: string;
    authorization: string;
    xLCTenant: string;
}

export interface DownloadFileVersionRequest {
    projectId: string;
    targetFileId: string;
    fileVersionId: string;
    authorization: string;
    xLCTenant: string;
}

export interface ExportTargetFileVersionRequest {
    projectId: string;
    targetFileId: string;
    fileVersionId: string;
    authorization: string;
    xLCTenant: string;
    format?: ExportTargetFileVersionFormatEnum;
}

export interface GetTargetFileRequest {
    projectId: string;
    targetFileId: string;
    authorization: string;
    xLCTenant: string;
    fields?: string;
}

export interface GetTargetFileVersionRequest {
    projectId: string;
    targetFileId: string;
    fileVersionId: string;
    authorization: string;
    xLCTenant: string;
    fields?: string;
}

export interface ImportTargetFileVersionRequest {
    projectId: string;
    targetFileId: string;
    authorization: string;
    xLCTenant: string;
    file: Blob;
}

export interface ListTargetFileVersionsRequest {
    projectId: string;
    targetFileId: string;
    authorization: string;
    xLCTenant: string;
    fields?: string;
}

export interface ListTargetFilesRequest {
    projectId: string;
    authorization: string;
    xLCTenant: string;
    targetFileIds?: Array<string>;
    sourceFileIds?: Array<string>;
    top?: number;
    skip?: number;
    fields?: string;
}

export interface PollTargetFileVersionExportRequest {
    projectId: string;
    targetFileId: string;
    fileVersionId: string;
    exportId: string;
    authorization: string;
    xLCTenant: string;
}

export interface PollTargetFileVersionImportRequest {
    projectId: string;
    targetFileId: string;
    importId: string;
    authorization: string;
    xLCTenant: string;
}

export interface UpdateTargetFileRequest {
    projectId: string;
    targetFileId: string;
    targetFileRenameRequest?: TargetFileRenameRequest;
}

export interface UpdateTargetFilesRequest {
    projectId: string;
    targetFilesUpdateRequest?: TargetFilesUpdateRequest;
}

/**
 * 
 */
export class TargetFileApi extends runtime.BaseAPI {

    /**
     * Adds a new  version of the target file. Only the `native` and `bcm` file formats are accepted. For the `sdlxliff` files, you should use the [Import Target File endpoint](../reference/Public-API.v1.json/paths/~1projects~1{projectId}~1target-files~1{targetFileId}~1versions~1imports/post). More information about file formats can be found on the [File formats](../docs/File-formats.md) page. Additional details on BCM files can be found [here](https://developers.rws.com/languagecloud-api-docs/articles/BCM.NET_client_API.html).  The version is added on the task represented by `taskId`. To be able to execute the add operation the task should be assigned and accepted by user. If the task is automatic, it is possible to add a target file version only if the status is `inProgress`.  The added file versions need to respect the output file type declared by the task type of the enclosing task. On the [Rules for sequencing tasks correctly](https://docs.rws.com/791595/885137/trados-enterprise/rules-for-sequencing-tasks-correctly) page from the official RWS Documentation Center, you can find out what output file type is supported by each task.  For adding a target file version using an extension task, the configuration of the task type must declare the `scope`\'s value as \"file\".  The multipart parameters in the body should respect and strictly follow the order specified in our documentation.  Consider the [file and project size limit](https://docs.rws.com/791595/815967/trados-enterprise---accelerate/file-and-project-size-limit) when uploading files.
     * Add Target File Version
     */
    async addTargetFileVersionRaw(requestParameters: AddTargetFileVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TargetFileVersionResponse>> {
        if (requestParameters['taskId'] == null) {
            throw new runtime.RequiredError(
                'taskId',
                'Required parameter "taskId" was null or undefined when calling addTargetFileVersion().'
            );
        }

        if (requestParameters['targetFileId'] == null) {
            throw new runtime.RequiredError(
                'targetFileId',
                'Required parameter "targetFileId" was null or undefined when calling addTargetFileVersion().'
            );
        }

        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling addTargetFileVersion().'
            );
        }

        if (requestParameters['xLCTenant'] == null) {
            throw new runtime.RequiredError(
                'xLCTenant',
                'Required parameter "xLCTenant" was null or undefined when calling addTargetFileVersion().'
            );
        }

        if (requestParameters['properties'] == null) {
            throw new runtime.RequiredError(
                'properties',
                'Required parameter "properties" was null or undefined when calling addTargetFileVersion().'
            );
        }

        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling addTargetFileVersion().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fields'] != null) {
            queryParameters['fields'] = requestParameters['fields'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        if (requestParameters['xLCTenant'] != null) {
            headerParameters['X-LC-Tenant'] = String(requestParameters['xLCTenant']);
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['properties'] != null) {

            formParams.append('properties', new Blob([JSON.stringify(requestParameters['properties'])], { type: "application/json", }));
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        const response = await this.request({
            path: `/tasks/{taskId}/target-files/{targetFileId}/versions`.replace(`{${"taskId"}}`, encodeURIComponent(String(requestParameters['taskId']))).replace(`{${"targetFileId"}}`, encodeURIComponent(String(requestParameters['targetFileId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Adds a new  version of the target file. Only the `native` and `bcm` file formats are accepted. For the `sdlxliff` files, you should use the [Import Target File endpoint](../reference/Public-API.v1.json/paths/~1projects~1{projectId}~1target-files~1{targetFileId}~1versions~1imports/post). More information about file formats can be found on the [File formats](../docs/File-formats.md) page. Additional details on BCM files can be found [here](https://developers.rws.com/languagecloud-api-docs/articles/BCM.NET_client_API.html).  The version is added on the task represented by `taskId`. To be able to execute the add operation the task should be assigned and accepted by user. If the task is automatic, it is possible to add a target file version only if the status is `inProgress`.  The added file versions need to respect the output file type declared by the task type of the enclosing task. On the [Rules for sequencing tasks correctly](https://docs.rws.com/791595/885137/trados-enterprise/rules-for-sequencing-tasks-correctly) page from the official RWS Documentation Center, you can find out what output file type is supported by each task.  For adding a target file version using an extension task, the configuration of the task type must declare the `scope`\'s value as \"file\".  The multipart parameters in the body should respect and strictly follow the order specified in our documentation.  Consider the [file and project size limit](https://docs.rws.com/791595/815967/trados-enterprise---accelerate/file-and-project-size-limit) when uploading files.
     * Add Target File Version
     */
    async addTargetFileVersion(requestParameters: AddTargetFileVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TargetFileVersionResponse> {
        const response = await this.addTargetFileVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Downloads a completed target file version via an export operation.
     * Download Exported Target File Version
     */
    async downloadExportedTargetFileVersionRaw(requestParameters: DownloadExportedTargetFileVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling downloadExportedTargetFileVersion().'
            );
        }

        if (requestParameters['targetFileId'] == null) {
            throw new runtime.RequiredError(
                'targetFileId',
                'Required parameter "targetFileId" was null or undefined when calling downloadExportedTargetFileVersion().'
            );
        }

        if (requestParameters['fileVersionId'] == null) {
            throw new runtime.RequiredError(
                'fileVersionId',
                'Required parameter "fileVersionId" was null or undefined when calling downloadExportedTargetFileVersion().'
            );
        }

        if (requestParameters['exportId'] == null) {
            throw new runtime.RequiredError(
                'exportId',
                'Required parameter "exportId" was null or undefined when calling downloadExportedTargetFileVersion().'
            );
        }

        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling downloadExportedTargetFileVersion().'
            );
        }

        if (requestParameters['xLCTenant'] == null) {
            throw new runtime.RequiredError(
                'xLCTenant',
                'Required parameter "xLCTenant" was null or undefined when calling downloadExportedTargetFileVersion().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        if (requestParameters['xLCTenant'] != null) {
            headerParameters['X-LC-Tenant'] = String(requestParameters['xLCTenant']);
        }

        const response = await this.request({
            path: `/projects/{projectId}/target-files/{targetFileId}/versions/{fileVersionId}/exports/{exportId}/download`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))).replace(`{${"targetFileId"}}`, encodeURIComponent(String(requestParameters['targetFileId']))).replace(`{${"fileVersionId"}}`, encodeURIComponent(String(requestParameters['fileVersionId']))).replace(`{${"exportId"}}`, encodeURIComponent(String(requestParameters['exportId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Downloads a completed target file version via an export operation.
     * Download Exported Target File Version
     */
    async downloadExportedTargetFileVersion(requestParameters: DownloadExportedTargetFileVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.downloadExportedTargetFileVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Downloads the file version (native or BCM).   If the `fileVersionId` path parameter represents a native file version, the native file will be downloaded. If the `fileVersionId` is an identifier of a version in [BCM format](https://developers.rws.com/languagecloud-api-docs/articles/BCM.NET_client_API.html), the BCM file will be downloaded.
     * Download Target File Version
     */
    async downloadFileVersionRaw(requestParameters: DownloadFileVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling downloadFileVersion().'
            );
        }

        if (requestParameters['targetFileId'] == null) {
            throw new runtime.RequiredError(
                'targetFileId',
                'Required parameter "targetFileId" was null or undefined when calling downloadFileVersion().'
            );
        }

        if (requestParameters['fileVersionId'] == null) {
            throw new runtime.RequiredError(
                'fileVersionId',
                'Required parameter "fileVersionId" was null or undefined when calling downloadFileVersion().'
            );
        }

        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling downloadFileVersion().'
            );
        }

        if (requestParameters['xLCTenant'] == null) {
            throw new runtime.RequiredError(
                'xLCTenant',
                'Required parameter "xLCTenant" was null or undefined when calling downloadFileVersion().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        if (requestParameters['xLCTenant'] != null) {
            headerParameters['X-LC-Tenant'] = String(requestParameters['xLCTenant']);
        }

        const response = await this.request({
            path: `/projects/{projectId}/target-files/{targetFileId}/versions/{fileVersionId}/download`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))).replace(`{${"targetFileId"}}`, encodeURIComponent(String(requestParameters['targetFileId']))).replace(`{${"fileVersionId"}}`, encodeURIComponent(String(requestParameters['fileVersionId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Downloads the file version (native or BCM).   If the `fileVersionId` path parameter represents a native file version, the native file will be downloaded. If the `fileVersionId` is an identifier of a version in [BCM format](https://developers.rws.com/languagecloud-api-docs/articles/BCM.NET_client_API.html), the BCM file will be downloaded.
     * Download Target File Version
     */
    async downloadFileVersion(requestParameters: DownloadFileVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.downloadFileVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generates an asynchronous export operation. Use the [Get Target File Version Export](../reference/Public-API.v1.json/paths/~1projects~1{projectId}~1target-files~1{targetFileId}~1versions~1{fileVersionId}~1exports~1{exportId}/get) endpoint to poll until the export is completed. Used only for [BCM](https://developers.rws.com/languagecloud-api-docs/articles/BCM.NET_client_API.html) file versions.  This operation triggers a conversion of the BCM target file version in a native or SDLXLIFF format, based on the value of the `format` query parameter used.  Consider the [file and project size limit](https://docs.rws.com/791595/815967/trados-enterprise---accelerate/file-and-project-size-limit) when uploading files.
     * Export Target File Version
     */
    async exportTargetFileVersionRaw(requestParameters: ExportTargetFileVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FileVersionExport>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling exportTargetFileVersion().'
            );
        }

        if (requestParameters['targetFileId'] == null) {
            throw new runtime.RequiredError(
                'targetFileId',
                'Required parameter "targetFileId" was null or undefined when calling exportTargetFileVersion().'
            );
        }

        if (requestParameters['fileVersionId'] == null) {
            throw new runtime.RequiredError(
                'fileVersionId',
                'Required parameter "fileVersionId" was null or undefined when calling exportTargetFileVersion().'
            );
        }

        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling exportTargetFileVersion().'
            );
        }

        if (requestParameters['xLCTenant'] == null) {
            throw new runtime.RequiredError(
                'xLCTenant',
                'Required parameter "xLCTenant" was null or undefined when calling exportTargetFileVersion().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        if (requestParameters['xLCTenant'] != null) {
            headerParameters['X-LC-Tenant'] = String(requestParameters['xLCTenant']);
        }

        const response = await this.request({
            path: `/projects/{projectId}/target-files/{targetFileId}/versions/{fileVersionId}/exports`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))).replace(`{${"targetFileId"}}`, encodeURIComponent(String(requestParameters['targetFileId']))).replace(`{${"fileVersionId"}}`, encodeURIComponent(String(requestParameters['fileVersionId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Generates an asynchronous export operation. Use the [Get Target File Version Export](../reference/Public-API.v1.json/paths/~1projects~1{projectId}~1target-files~1{targetFileId}~1versions~1{fileVersionId}~1exports~1{exportId}/get) endpoint to poll until the export is completed. Used only for [BCM](https://developers.rws.com/languagecloud-api-docs/articles/BCM.NET_client_API.html) file versions.  This operation triggers a conversion of the BCM target file version in a native or SDLXLIFF format, based on the value of the `format` query parameter used.  Consider the [file and project size limit](https://docs.rws.com/791595/815967/trados-enterprise---accelerate/file-and-project-size-limit) when uploading files.
     * Export Target File Version
     */
    async exportTargetFileVersion(requestParameters: ExportTargetFileVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FileVersionExport> {
        const response = await this.exportTargetFileVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a target file from a project.
     * Get Target File
     */
    async getTargetFileRaw(requestParameters: GetTargetFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TargetFile>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling getTargetFile().'
            );
        }

        if (requestParameters['targetFileId'] == null) {
            throw new runtime.RequiredError(
                'targetFileId',
                'Required parameter "targetFileId" was null or undefined when calling getTargetFile().'
            );
        }

        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling getTargetFile().'
            );
        }

        if (requestParameters['xLCTenant'] == null) {
            throw new runtime.RequiredError(
                'xLCTenant',
                'Required parameter "xLCTenant" was null or undefined when calling getTargetFile().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fields'] != null) {
            queryParameters['fields'] = requestParameters['fields'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        if (requestParameters['xLCTenant'] != null) {
            headerParameters['X-LC-Tenant'] = String(requestParameters['xLCTenant']);
        }

        const response = await this.request({
            path: `/projects/{projectId}/target-files/{targetFileId}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))).replace(`{${"targetFileId"}}`, encodeURIComponent(String(requestParameters['targetFileId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves a target file from a project.
     * Get Target File
     */
    async getTargetFile(requestParameters: GetTargetFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TargetFile> {
        const response = await this.getTargetFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves one version of a target file.
     * Get Target File Version
     */
    async getTargetFileVersionRaw(requestParameters: GetTargetFileVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TargetFileVersion>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling getTargetFileVersion().'
            );
        }

        if (requestParameters['targetFileId'] == null) {
            throw new runtime.RequiredError(
                'targetFileId',
                'Required parameter "targetFileId" was null or undefined when calling getTargetFileVersion().'
            );
        }

        if (requestParameters['fileVersionId'] == null) {
            throw new runtime.RequiredError(
                'fileVersionId',
                'Required parameter "fileVersionId" was null or undefined when calling getTargetFileVersion().'
            );
        }

        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling getTargetFileVersion().'
            );
        }

        if (requestParameters['xLCTenant'] == null) {
            throw new runtime.RequiredError(
                'xLCTenant',
                'Required parameter "xLCTenant" was null or undefined when calling getTargetFileVersion().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fields'] != null) {
            queryParameters['fields'] = requestParameters['fields'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        if (requestParameters['xLCTenant'] != null) {
            headerParameters['X-LC-Tenant'] = String(requestParameters['xLCTenant']);
        }

        const response = await this.request({
            path: `/projects/{projectId}/target-files/{targetFileId}/versions/{fileVersionId}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))).replace(`{${"targetFileId"}}`, encodeURIComponent(String(requestParameters['targetFileId']))).replace(`{${"fileVersionId"}}`, encodeURIComponent(String(requestParameters['fileVersionId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves one version of a target file.
     * Get Target File Version
     */
    async getTargetFileVersion(requestParameters: GetTargetFileVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TargetFileVersion> {
        const response = await this.getTargetFileVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generates an asynchronous import operation. Use [Poll Target File Version Import endpoint](../reference/Public-API.v1.json/paths/~1projects~1{projectId}~1target-files~1{targetFileId}~1versions~1imports~1{importId}/get) to poll until the import is completed. Only `sdlxliff` files can be imported.  Import should be used when a file is downloaded as an `sdlxliff`, processed and then, replaced.  The import operation triggers internally the update of the [BCM](https://developers.rws.com/languagecloud-api-docs/articles/BCM.NET_client_API.html) file associated with the imported file. It should mostly be used for offline work.  Consider the [file and project size limit](https://docs.rws.com/791595/815967/trados-enterprise---accelerate/file-and-project-size-limit) when uploading files.
     * Import Target File Version
     */
    async importTargetFileVersionRaw(requestParameters: ImportTargetFileVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FileVersionImport>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling importTargetFileVersion().'
            );
        }

        if (requestParameters['targetFileId'] == null) {
            throw new runtime.RequiredError(
                'targetFileId',
                'Required parameter "targetFileId" was null or undefined when calling importTargetFileVersion().'
            );
        }

        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling importTargetFileVersion().'
            );
        }

        if (requestParameters['xLCTenant'] == null) {
            throw new runtime.RequiredError(
                'xLCTenant',
                'Required parameter "xLCTenant" was null or undefined when calling importTargetFileVersion().'
            );
        }

        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling importTargetFileVersion().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        if (requestParameters['xLCTenant'] != null) {
            headerParameters['X-LC-Tenant'] = String(requestParameters['xLCTenant']);
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        const response = await this.request({
            path: `/projects/{projectId}/target-files/{targetFileId}/versions/imports`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))).replace(`{${"targetFileId"}}`, encodeURIComponent(String(requestParameters['targetFileId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Generates an asynchronous import operation. Use [Poll Target File Version Import endpoint](../reference/Public-API.v1.json/paths/~1projects~1{projectId}~1target-files~1{targetFileId}~1versions~1imports~1{importId}/get) to poll until the import is completed. Only `sdlxliff` files can be imported.  Import should be used when a file is downloaded as an `sdlxliff`, processed and then, replaced.  The import operation triggers internally the update of the [BCM](https://developers.rws.com/languagecloud-api-docs/articles/BCM.NET_client_API.html) file associated with the imported file. It should mostly be used for offline work.  Consider the [file and project size limit](https://docs.rws.com/791595/815967/trados-enterprise---accelerate/file-and-project-size-limit) when uploading files.
     * Import Target File Version
     */
    async importTargetFileVersion(requestParameters: ImportTargetFileVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FileVersionImport> {
        const response = await this.importTargetFileVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the versions of a target file.
     * List Target File Versions
     */
    async listTargetFileVersionsRaw(requestParameters: ListTargetFileVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListTargetFileVersionsResponse>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling listTargetFileVersions().'
            );
        }

        if (requestParameters['targetFileId'] == null) {
            throw new runtime.RequiredError(
                'targetFileId',
                'Required parameter "targetFileId" was null or undefined when calling listTargetFileVersions().'
            );
        }

        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling listTargetFileVersions().'
            );
        }

        if (requestParameters['xLCTenant'] == null) {
            throw new runtime.RequiredError(
                'xLCTenant',
                'Required parameter "xLCTenant" was null or undefined when calling listTargetFileVersions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fields'] != null) {
            queryParameters['fields'] = requestParameters['fields'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        if (requestParameters['xLCTenant'] != null) {
            headerParameters['X-LC-Tenant'] = String(requestParameters['xLCTenant']);
        }

        const response = await this.request({
            path: `/projects/{projectId}/target-files/{targetFileId}/versions`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))).replace(`{${"targetFileId"}}`, encodeURIComponent(String(requestParameters['targetFileId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the versions of a target file.
     * List Target File Versions
     */
    async listTargetFileVersions(requestParameters: ListTargetFileVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListTargetFileVersionsResponse> {
        const response = await this.listTargetFileVersionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the target files for a project.
     * List Target Files
     */
    async listTargetFilesRaw(requestParameters: ListTargetFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListTargetFilesResponse>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling listTargetFiles().'
            );
        }

        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling listTargetFiles().'
            );
        }

        if (requestParameters['xLCTenant'] == null) {
            throw new runtime.RequiredError(
                'xLCTenant',
                'Required parameter "xLCTenant" was null or undefined when calling listTargetFiles().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['targetFileIds'] != null) {
            queryParameters['targetFileIds'] = requestParameters['targetFileIds']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['sourceFileIds'] != null) {
            queryParameters['sourceFileIds'] = requestParameters['sourceFileIds']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['top'] != null) {
            queryParameters['top'] = requestParameters['top'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['fields'] != null) {
            queryParameters['fields'] = requestParameters['fields'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        if (requestParameters['xLCTenant'] != null) {
            headerParameters['X-LC-Tenant'] = String(requestParameters['xLCTenant']);
        }

        const response = await this.request({
            path: `/projects/{projectId}/target-files`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the target files for a project.
     * List Target Files
     */
    async listTargetFiles(requestParameters: ListTargetFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListTargetFilesResponse> {
        const response = await this.listTargetFilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Polls a target file version via an export operation. The new version can be downloaded once the status is \"completed\".
     * Poll Target File Version Export
     */
    async pollTargetFileVersionExportRaw(requestParameters: PollTargetFileVersionExportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FileVersionExport>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling pollTargetFileVersionExport().'
            );
        }

        if (requestParameters['targetFileId'] == null) {
            throw new runtime.RequiredError(
                'targetFileId',
                'Required parameter "targetFileId" was null or undefined when calling pollTargetFileVersionExport().'
            );
        }

        if (requestParameters['fileVersionId'] == null) {
            throw new runtime.RequiredError(
                'fileVersionId',
                'Required parameter "fileVersionId" was null or undefined when calling pollTargetFileVersionExport().'
            );
        }

        if (requestParameters['exportId'] == null) {
            throw new runtime.RequiredError(
                'exportId',
                'Required parameter "exportId" was null or undefined when calling pollTargetFileVersionExport().'
            );
        }

        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling pollTargetFileVersionExport().'
            );
        }

        if (requestParameters['xLCTenant'] == null) {
            throw new runtime.RequiredError(
                'xLCTenant',
                'Required parameter "xLCTenant" was null or undefined when calling pollTargetFileVersionExport().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        if (requestParameters['xLCTenant'] != null) {
            headerParameters['X-LC-Tenant'] = String(requestParameters['xLCTenant']);
        }

        const response = await this.request({
            path: `/projects/{projectId}/target-files/{targetFileId}/versions/{fileVersionId}/exports/{exportId}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))).replace(`{${"targetFileId"}}`, encodeURIComponent(String(requestParameters['targetFileId']))).replace(`{${"fileVersionId"}}`, encodeURIComponent(String(requestParameters['fileVersionId']))).replace(`{${"exportId"}}`, encodeURIComponent(String(requestParameters['exportId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Polls a target file version via an export operation. The new version can be downloaded once the status is \"completed\".
     * Poll Target File Version Export
     */
    async pollTargetFileVersionExport(requestParameters: PollTargetFileVersionExportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FileVersionExport> {
        const response = await this.pollTargetFileVersionExportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Polls a target file version via an import operation. The new version can be seen on the file versions once the status is \"completed\".
     * Poll Target File Version Import
     */
    async pollTargetFileVersionImportRaw(requestParameters: PollTargetFileVersionImportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FileVersionImport>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling pollTargetFileVersionImport().'
            );
        }

        if (requestParameters['targetFileId'] == null) {
            throw new runtime.RequiredError(
                'targetFileId',
                'Required parameter "targetFileId" was null or undefined when calling pollTargetFileVersionImport().'
            );
        }

        if (requestParameters['importId'] == null) {
            throw new runtime.RequiredError(
                'importId',
                'Required parameter "importId" was null or undefined when calling pollTargetFileVersionImport().'
            );
        }

        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling pollTargetFileVersionImport().'
            );
        }

        if (requestParameters['xLCTenant'] == null) {
            throw new runtime.RequiredError(
                'xLCTenant',
                'Required parameter "xLCTenant" was null or undefined when calling pollTargetFileVersionImport().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        if (requestParameters['xLCTenant'] != null) {
            headerParameters['X-LC-Tenant'] = String(requestParameters['xLCTenant']);
        }

        const response = await this.request({
            path: `/projects/{projectId}/target-files/{targetFileId}/versions/imports/{importId}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))).replace(`{${"targetFileId"}}`, encodeURIComponent(String(requestParameters['targetFileId']))).replace(`{${"importId"}}`, encodeURIComponent(String(requestParameters['importId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Polls a target file version via an import operation. The new version can be seen on the file versions once the status is \"completed\".
     * Poll Target File Version Import
     */
    async pollTargetFileVersionImport(requestParameters: PollTargetFileVersionImportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FileVersionImport> {
        const response = await this.pollTargetFileVersionImportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a target file.
     * Update Target File
     */
    async updateTargetFileRaw(requestParameters: UpdateTargetFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling updateTargetFile().'
            );
        }

        if (requestParameters['targetFileId'] == null) {
            throw new runtime.RequiredError(
                'targetFileId',
                'Required parameter "targetFileId" was null or undefined when calling updateTargetFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/projects/{projectId}/target-files/{targetFileId}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))).replace(`{${"targetFileId"}}`, encodeURIComponent(String(requestParameters['targetFileId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['targetFileRenameRequest'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates a target file.
     * Update Target File
     */
    async updateTargetFile(requestParameters: UpdateTargetFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateTargetFileRaw(requestParameters, initOverrides);
    }

    /**
     * Updates multiple target files. If any of the files fails to be updated, an error will be returned for each file. 
     * Update Target Files
     */
    async updateTargetFilesRaw(requestParameters: UpdateTargetFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling updateTargetFiles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/projects/{projectId}/target-files`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['targetFilesUpdateRequest'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates multiple target files. If any of the files fails to be updated, an error will be returned for each file. 
     * Update Target Files
     */
    async updateTargetFiles(requestParameters: UpdateTargetFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateTargetFilesRaw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const ExportTargetFileVersionFormatEnum = {
    Native: 'native',
    Sdlxliff: 'sdlxliff'
} as const;
export type ExportTargetFileVersionFormatEnum = typeof ExportTargetFileVersionFormatEnum[keyof typeof ExportTargetFileVersionFormatEnum];
